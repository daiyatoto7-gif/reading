<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>読書管理アプリ</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            /* Dark Theme Colors */
            --bg-color: #121212;
            --card-bg: #1e1e1e;
            --text-color: #e0e0e0;
            --text-muted: #a0a0a0;
            --primary-color: #64b5f6; /* Lighter blue for dark mode */
            --border-color: #333;
            --input-bg: #2c2c2c;
            
            --status-unread: #757575;
            --status-reading: #4caf50; /* Green for active */
            --status-completed: #2196f3; /* Blue for done */
            --status-dropped: #f44336; /* Red */
        }

        body {
            font-family: "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            padding-bottom: 80px; /* Nav height */
        }

        h2, h3 { margin-top: 0; color: #fff; }

        /* Navigation Tabs */
        .nav-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: var(--card-bg);
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-around;
            padding: 10px 0;
            z-index: 1000;
        }
        .nav-item {
            text-align: center;
            cursor: pointer;
            flex: 1;
            padding: 5px;
            color: var(--text-muted);
            font-size: 12px;
        }
        .nav-item.active {
            color: var(--primary-color);
            font-weight: bold;
        }

        /* Page Layout */
        .page {
            display: none;
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
        }
        .page.active { display: block; }

        /* Cards & Inputs */
        .card {
            background: var(--card-bg);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }
        input, select, textarea {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: white;
            box-sizing: border-box;
        }
        input[type="date"] {
            color-scheme: dark;
        }
        button {
            background-color: var(--primary-color);
            color: #121212;
            border: none;
            padding: 12px 20px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            font-size: 16px;
            font-weight: bold;
        }
        button:hover { opacity: 0.9; }
        button.secondary { background-color: #424242; color: white; margin-top: 5px; }
        button.danger { background-color: #cf6679; color: black; margin-top: 5px; }

        /* Utility */
        .hidden { display: none; }
        .flex { display: flex; gap: 10px; }
        .text-small { font-size: 12px; color: var(--text-muted); }
        
        /* Badges */
        .status-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            color: white;
            margin-left: 8px;
        }
        .status-unread { background-color: var(--status-unread); }
        .status-reading { background-color: var(--status-reading); }
        .status-completed { background-color: var(--status-completed); }
        .status-dropped { background-color: var(--status-dropped); }

        /* Lists */
        .book-item {
            border-bottom: 1px solid var(--border-color);
            padding: 15px 0;
        }
        .book-item:last-child { border-bottom: none; }

        /* Calendar (Month View) */
        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background-color: var(--border-color);
        }
        .calendar-cell {
            background-color: var(--card-bg);
            min-height: 80px;
            padding: 5px;
            position: relative;
        }
        .calendar-day-header {
            background-color: #333;
            color: #ccc;
            text-align: center;
            padding: 5px;
            font-size: 12px;
        }
        .day-number {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 4px;
            display: block;
        }
        .calendar-event {
            font-size: 10px;
            background-color: var(--primary-color);
            color: #121212;
            padding: 2px 4px;
            border-radius: 2px;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .event-continue { opacity: 0.7; }

        /* Memo History */
        .memo-history {
            margin-top: 10px;
            padding: 10px;
            background: #252525;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
        }
        .memo-item {
            border-bottom: 1px solid #444;
            padding: 8px 0;
            font-size: 13px;
        }
        .memo-date { color: var(--primary-color); font-weight: bold; margin-right: 5px; }

        /* Chart adjustments */
        canvas { max-width: 100%; margin-bottom: 20px; }
    </style>
</head>
<body>

    <div id="tab-record" class="page active">
        <h2>記録をつける</h2>
        <div class="card">
            <h3>メニュー</h3>
            <div class="flex">
                <button onclick="showRecordSection('add-new')">新しい本を追加</button>
                <button onclick="showRecordSection('log-reading')">読書記録をつける</button>
            </div>
            <div style="margin-top: 10px;">
                <button class="secondary" onclick="showRecordSection('change-status')">ステータスを変更</button>
            </div>
        </div>

        <div id="section-add-new" class="card hidden">
            <h3>新しい本を追加</h3>
            <label>タイトル (必須)</label>
            <input type="text" id="new-title" placeholder="本のタイトル">
            
            <label>読み始めた日 (空欄なら自動)</label>
            <input type="date" id="new-start-date">
            
            <label>今回読んだ日付 (任意)</label>
            <input type="date" id="new-log-date">
            
            <label>どこまで読んだか (ページ数)</label>
            <input type="number" id="new-page" placeholder="例: 50">
            
            <label>読み終えた日 (読了時のみ)</label>
            <input type="date" id="new-finish-date">
            
            <label>メモ</label>
            <textarea id="new-memo" placeholder="感想など"></textarea>
            
            <button onclick="addNewBook()">追加する</button>
        </div>

        <div id="section-log-reading" class="card hidden">
            <h3>読書記録をつける</h3>
            <p class="text-small">未読または読書中の本のみ表示</p>
            <select id="log-book-select" onchange="updateCurrentPageDisplay()"></select>
            
            <p id="current-page-display" style="font-weight:bold; color:var(--primary-color);">現在: 0ページ</p>

            <label>読んだ日付</label>
            <input type="date" id="log-date">
            
            <label>どこまで読んだか (ページ数)</label>
            <input type="number" id="log-page">
            
            <label>メモ</label>
            <textarea id="log-memo" placeholder="今日の感想"></textarea>
            
            <button onclick="addLog()">記録する</button>
            
            <div class="flex" style="margin-top:10px;">
                <button class="secondary" onclick="finishBookFromLog()">読了する</button>
                <button class="danger" onclick="dropBookFromLog()">離脱する</button>
            </div>
        </div>

        <div id="section-change-status" class="card hidden">
            <h3>ステータスを変更・編集</h3>
            <input type="text" id="status-search" placeholder="本の名前で検索..." onkeyup="renderStatusList()">
            <div id="status-book-list"></div>
        </div>
    </div>

    <div id="tab-bookshelf" class="page">
        <h2>本棚</h2>
        <div class="flex" style="margin-bottom: 15px;">
            <button class="secondary" onclick="renderBookshelf('reading')">読書中</button>
            <button class="secondary" onclick="renderBookshelf('all')">すべて</button>
            <button class="secondary" onclick="renderBookshelf('unread')">未読</button>
            <button class="secondary" onclick="renderBookshelf('dropped')">離脱</button>
        </div>
        <div id="bookshelf-list" class="card"></div>
    </div>

    <div id="edit-screen" class="page">
        <button class="secondary" onclick="closeEditScreen()" style="width:auto; margin-bottom:10px;">← 戻る</button>
        <h2>詳細編集</h2>
        <div class="card">
            <input type="hidden" id="edit-id">
            <label>タイトル</label>
            <input type="text" id="edit-title">
            
            <label>ステータス</label>
            <select id="edit-status">
                <option value="unread">未読</option>
                <option value="reading">読書中</option>
                <option value="completed">読了</option>
                <option value="dropped">離脱中</option>
            </select>

            <label>読み始めた日</label>
            <input type="date" id="edit-start-date">

            <label>現在の到達ページ（記録を追加）</label>
            <p class="text-small">過去の記録を修正する場合は下部の履歴から行えないため、削除して入れ直す等の対応が必要です。ここでは最新の到達ページを上書き・追加します。</p>
            <input type="number" id="edit-current-page">

            <label>読み終えた日</label>
            <input type="date" id="edit-finish-date">

            <h3>読書履歴・メモ</h3>
            <div id="edit-memo-history" class="memo-history"></div>

            <button onclick="saveEdit()" style="margin-top:20px;">変更を保存</button>
            <button class="danger" onclick="deleteBook()" style="margin-top:10px;">この本を削除</button>
        </div>
    </div>

    <div id="tab-calendar" class="page">
        <h2>カレンダー</h2>
        <div class="card">
            <div class="calendar-header">
                <button class="secondary" style="width:auto;" onclick="changeMonth(-1)">Previous</button>
                <h3 id="calendar-title" style="margin:0;">2024年 1月</h3>
                <button class="secondary" style="width:auto;" onclick="changeMonth(1)">Next</button>
            </div>
            <div class="calendar-grid" id="calendar-grid">
                </div>
        </div>
    </div>

    <div id="tab-stats" class="page">
        <h2>統計情報</h2>
        <div class="card">
            <p><strong>累計読了冊数:</strong> <span id="stat-total-completed">0</span> 冊</p>
            <p><strong>累計読書ページ数:</strong> <span id="stat-total-pages">0</span> ページ</p>
            <p><strong>1日平均ページ数:</strong> <span id="stat-avg-daily-page">0</span> ページ<br>
                <span class="text-small">※最初の読書日から今日までの全日数(読まなかった日含む)で計算</span>
            </p>
            <p><strong>1冊平均読了日数:</strong> <span id="stat-avg-days-book">0</span> 日</p>
        </div>
        <div class="card">
            <h3>月別読了冊数</h3>
            <canvas id="chart-monthly-books"></canvas>
        </div>
        <div class="card">
            <h3>日別読書ページ推移</h3>
            <canvas id="chart-daily-pages"></canvas>
        </div>
    </div>

    <div class="nav-bar">
        <div class="nav-item active" onclick="switchTab('record')">記録</div>
        <div class="nav-item" onclick="switchTab('bookshelf')">本棚</div>
        <div class="nav-item" onclick="switchTab('calendar')">カレンダー</div>
        <div class="nav-item" onclick="switchTab('stats')">統計</div>
    </div>

    <script>
        // --- Data & Initialization ---
        let books = JSON.parse(localStorage.getItem('readingApp_books')) || [];
        let currentCalendarDate = new Date();

        function saveData() {
            localStorage.setItem('readingApp_books', JSON.stringify(books));
        }

        // Dark mode chart defaults
        Chart.defaults.color = '#a0a0a0';
        Chart.defaults.borderColor = '#333';

        // --- Tab Switching ---
        function switchTab(tabName) {
            document.querySelectorAll('.page').forEach(el => el.classList.remove('active'));
            document.getElementById(`tab-${tabName}`).classList.add('active');
            
            document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
            const navIndex = ['record', 'bookshelf', 'calendar', 'stats'].indexOf(tabName);
            if(navIndex >= 0) document.querySelectorAll('.nav-item')[navIndex].classList.add('active');

            if(tabName === 'record') resetRecordForms();
            if(tabName === 'bookshelf') renderBookshelf('all');
            if(tabName === 'calendar') renderCalendar();
            if(tabName === 'stats') renderStats();
        }

        // --- Record Logic ---
        function showRecordSection(section) {
            document.getElementById('section-add-new').classList.add('hidden');
            document.getElementById('section-log-reading').classList.add('hidden');
            document.getElementById('section-change-status').classList.add('hidden');
            document.getElementById(`section-${section}`).classList.remove('hidden');
            if(section === 'log-reading') populateLogSelect();
            if(section === 'change-status') renderStatusList();
        }

        function resetRecordForms() {
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('new-log-date').value = today;
            document.getElementById('log-date').value = today;
        }

        function addNewBook() {
            const title = document.getElementById('new-title').value;
            if(!title) return alert("タイトルは必須です");

            const startDate = document.getElementById('new-start-date').value;
            const logDate = document.getElementById('new-log-date').value;
            const page = parseInt(document.getElementById('new-page').value) || 0;
            const finishDate = document.getElementById('new-finish-date').value;
            const memo = document.getElementById('new-memo').value;

            const newBook = {
                id: Date.now(),
                title: title,
                status: 'unread',
                startDate: startDate || '',
                finishDate: finishDate || '',
                logs: []
            };

            if(logDate || page > 0) {
                if(!newBook.startDate && logDate) newBook.startDate = logDate;
                newBook.status = 'reading';
                if(finishDate) newBook.status = 'completed';

                newBook.logs.push({
                    date: logDate || new Date().toISOString().split('T')[0],
                    page: page,
                    memo: memo
                });
            }

            books.push(newBook);
            saveData();
            alert("本を追加しました");
            
            document.getElementById('new-title').value = '';
            document.getElementById('new-page').value = '';
            document.getElementById('new-memo').value = '';
            showRecordSection('log-reading');
        }

        function populateLogSelect() {
            const select = document.getElementById('log-book-select');
            select.innerHTML = '<option value="">本を選択してください</option>';
            const activeBooks = books.filter(b => b.status === 'unread' || b.status === 'reading');
            activeBooks.forEach(b => {
                const opt = document.createElement('option');
                opt.value = b.id;
                opt.textContent = b.title;
                select.appendChild(opt);
            });
        }

        function updateCurrentPageDisplay() {
            const bookId = document.getElementById('log-book-select').value;
            const display = document.getElementById('current-page-display');
            if(!bookId) {
                display.innerText = "現在: - ページ";
                return;
            }
            const book = books.find(b => b.id == bookId);
            const maxPage = book.logs.length > 0 ? book.logs[book.logs.length - 1].page : 0;
            display.innerText = `現在: ${maxPage} ページ`;
        }

        function addLog() {
            const bookId = document.getElementById('log-book-select').value;
            if(!bookId) return alert("本を選択してください");
            
            const date = document.getElementById('log-date').value;
            const page = parseInt(document.getElementById('log-page').value);
            const memo = document.getElementById('log-memo').value;

            if(!date || isNaN(page)) return alert("日付とページ数は必須です");

            const book = books.find(b => b.id == bookId);
            const currentPage = book.logs.length > 0 ? book.logs[book.logs.length - 1].page : 0;
            
            if(page < currentPage) {
                alert(`エラー: ページ数が減っています（現在: ${currentPage}）。\n記録修正は「本棚」の編集から行ってください。`);
                return;
            }

            if(book.status === 'unread') {
                book.status = 'reading';
                if(!book.startDate) book.startDate = date;
            }

            // Push new log (keeps history of all dates)
            book.logs.push({ date, page, memo });
            book.logs.sort((a,b) => new Date(a.date) - new Date(b.date));

            saveData();
            alert("記録しました");
            document.getElementById('log-memo').value = ''; 
            document.getElementById('log-page').value = '';
            updateCurrentPageDisplay();
        }

        function finishBookFromLog() {
            const bookId = document.getElementById('log-book-select').value;
            if(!bookId) return alert("本を選択してください");
            const date = document.getElementById('log-date').value;
            const book = books.find(b => b.id == bookId);
            book.status = 'completed';
            book.finishDate = date || new Date().toISOString().split('T')[0];
            saveData();
            alert("「読了」に変更しました");
            populateLogSelect();
        }

        function dropBookFromLog() {
            const bookId = document.getElementById('log-book-select').value;
            if(!bookId) return alert("本を選択してください");
            const book = books.find(b => b.id == bookId);
            book.status = 'dropped';
            saveData();
            alert("「離脱」に変更しました");
            populateLogSelect();
        }

        function renderStatusList() {
            const container = document.getElementById('status-book-list');
            const search = document.getElementById('status-search').value.toLowerCase();
            container.innerHTML = '';
            const filtered = books.filter(b => b.title.toLowerCase().includes(search));
            filtered.forEach(b => {
                const div = document.createElement('div');
                div.className = 'book-item flex';
                div.style.justifyContent = 'space-between';
                div.innerHTML = `
                    <span>${b.title} <span class="status-badge status-${b.status}">${getStatusLabel(b.status)}</span></span>
                    <button class="secondary" style="width:auto; padding:5px 10px;" onclick="openEditScreen(${b.id})">編集</button>
                `;
                container.appendChild(div);
            });
        }

        // --- Bookshelf Logic ---
        function renderBookshelf(filterStatus) {
            const list = document.getElementById('bookshelf-list');
            list.innerHTML = '';
            let filtered = books;
            if(filterStatus !== 'all') filtered = books.filter(b => b.status === filterStatus);
            if(filtered.length === 0) {
                list.innerHTML = '<p style="text-align:center; color:#777;">本がありません</p>';
                return;
            }
            filtered.forEach(b => {
                const div = document.createElement('div');
                div.className = 'book-item';
                div.innerHTML = `
                    <div class="flex" style="justify-content:space-between; align-items:center;">
                        <div>
                            <strong>${b.title}</strong>
                            <span class="status-badge status-${b.status}">${getStatusLabel(b.status)}</span>
                            <div class="text-small" style="margin-top:4px;">開始: ${b.startDate || '-'} / 完了: ${b.finishDate || '-'}</div>
                        </div>
                        <button class="secondary" style="width:auto;" onclick="openEditScreen(${b.id})">編集</button>
                    </div>
                `;
                list.appendChild(div);
            });
        }
        
        function getStatusLabel(status) {
            const map = { unread:'未読', reading:'読書中', completed:'読了', dropped:'離脱' };
            return map[status] || status;
        }

        // --- Edit Logic ---
        function openEditScreen(id) {
            const book = books.find(b => b.id == id);
            if(!book) return;

            document.getElementById('edit-id').value = book.id;
            document.getElementById('edit-title').value = book.title;
            document.getElementById('edit-status').value = book.status;
            document.getElementById('edit-start-date').value = book.startDate;
            document.getElementById('edit-finish-date').value = book.finishDate;
            
            const currentP = book.logs.length > 0 ? book.logs[book.logs.length - 1].page : 0;
            document.getElementById('edit-current-page').value = currentP;

            const historyDiv = document.getElementById('edit-memo-history');
            historyDiv.innerHTML = '';
            // Display history: Date + Page + Memo
            const sortedLogs = [...book.logs].sort((a,b) => new Date(b.date) - new Date(a.date));
            sortedLogs.forEach(log => {
                const d = document.createElement('div');
                d.className = 'memo-item';
                d.innerHTML = `<span class="memo-date">${log.date}</span> ${log.page}ページまで <br> ${log.memo || '(メモなし)'}`;
                historyDiv.appendChild(d);
            });

            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            document.getElementById('edit-screen').classList.add('active');
        }

        function closeEditScreen() {
            document.getElementById('edit-screen').classList.remove('active');
            switchTab('bookshelf');
        }

        function saveEdit() {
            const id = document.getElementById('edit-id').value;
            const book = books.find(b => b.id == id);

            book.title = document.getElementById('edit-title').value;
            book.status = document.getElementById('edit-status').value;
            book.startDate = document.getElementById('edit-start-date').value;
            book.finishDate = document.getElementById('edit-finish-date').value;

            // Handle manual page update in edit screen
            const inputPage = parseInt(document.getElementById('edit-current-page').value);
            // Check if this page value differs from the last log
            const lastLog = book.logs.length > 0 ? book.logs[book.logs.length - 1] : null;
            
            // Only add a new log if page count changed from last record
            if (!lastLog || lastLog.page !== inputPage) {
                 book.logs.push({ 
                     date: new Date().toISOString().split('T')[0], 
                     page: inputPage, 
                     memo: '編集画面で更新' 
                 });
                 // Re-sort in case date order is messy
                 book.logs.sort((a,b) => new Date(a.date) - new Date(b.date));
            }

            saveData();
            alert("変更を保存しました");
            closeEditScreen();
        }

        function deleteBook() {
            if(!confirm("本当に削除しますか？")) return;
            const id = document.getElementById('edit-id').value;
            books = books.filter(b => b.id != id);
            saveData();
            closeEditScreen();
        }

        // --- Calendar Logic (Monthly Grid) ---
        function changeMonth(offset) {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() + offset);
            renderCalendar();
        }

        function renderCalendar() {
            const year = currentCalendarDate.getFullYear();
            const month = currentCalendarDate.getMonth();
            
            document.getElementById('calendar-title').innerText = `${year}年 ${month + 1}月`;
            
            const grid = document.getElementById('calendar-grid');
            grid.innerHTML = '';

            // Add Headers
            const days = ['日', '月', '火', '水', '木', '金', '土'];
            days.forEach(d => {
                const h = document.createElement('div');
                h.className = 'calendar-day-header';
                h.innerText = d;
                grid.appendChild(h);
            });

            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            
            const startDayIndex = firstDay.getDay(); // 0(Sun) - 6(Sat)
            const totalDays = lastDay.getDate();

            // Empty slots for prev month
            for(let i=0; i<startDayIndex; i++) {
                const empty = document.createElement('div');
                empty.className = 'calendar-cell';
                empty.style.backgroundColor = 'transparent';
                grid.appendChild(empty);
            }

            // Days
            const todayStr = new Date().toISOString().split('T')[0];
            
            for(let d=1; d<=totalDays; d++) {
                const cellDate = new Date(year, month, d);
                const cellDateStr = cellDate.toISOString().split('T')[0];
                
                const cell = document.createElement('div');
                cell.className = 'calendar-cell';
                if(cellDateStr === todayStr) cell.style.border = '1px solid var(--primary-color)';

                cell.innerHTML = `<span class="day-number">${d}</span>`;

                // Find active books for this date
                // Active if: startDate <= thisDate AND (finishDate >= thisDate OR (status is reading/unread and thisDate <= today))
                // Note: Don't show dropped books as per request.
                
                books.forEach(b => {
                    if(b.status === 'dropped' || !b.startDate) return;
                    
                    const start = new Date(b.startDate);
                    start.setHours(0,0,0,0);
                    
                    // Determine end of range
                    let end;
                    if(b.finishDate) {
                        end = new Date(b.finishDate);
                    } else {
                        // If reading, assume it continues until today (or beyond?)
                        // User wants to see "periods being read". Usually up to today.
                        end = new Date(); 
                    }
                    end.setHours(0,0,0,0);

                    if (cellDate >= start && cellDate <= end) {
                        const eventDiv = document.createElement('div');
                        eventDiv.className = 'calendar-event';
                        eventDiv.innerText = b.title;
                        cell.appendChild(eventDiv);
                    }
                });

                grid.appendChild(cell);
            }
        }

        // --- Statistics Logic (Revised) ---
        let chart1 = null;
        let chart2 = null;

        function renderStats() {
            const completedBooks = books.filter(b => b.status === 'completed');
            
            // 1. Total Pages (Max page of each book sum)
            let totalPages = 0;
            books.forEach(b => {
                if(b.logs.length > 0) {
                    totalPages += Math.max(...b.logs.map(l => l.page));
                }
            });

            // 2. Avg Daily Pages
            // Logic: Total Pages / Days since first ever log to Today
            let avgDaily = 0;
            let allLogsDates = [];
            books.forEach(b => b.logs.forEach(l => allLogsDates.push(new Date(l.date))));
            
            if(allLogsDates.length > 0) {
                const minDate = new Date(Math.min.apply(null, allLogsDates));
                const maxDate = new Date(); // Until today
                const diffTime = Math.abs(maxDate - minDate);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) || 1; 
                avgDaily = Math.round(totalPages / diffDays);
            }

            // 3. Avg Days per Book (Completed only)
            let totalDaysForBooks = 0;
            completedBooks.forEach(b => {
                const s = new Date(b.startDate);
                const e = new Date(b.finishDate);
                const d = Math.max(1, Math.ceil((e - s) / (1000 * 60 * 60 * 24)) + 1);
                totalDaysForBooks += d;
            });
            const avgDaysBook = completedBooks.length > 0 ? Math.round(totalDaysForBooks / completedBooks.length) : 0;

            document.getElementById('stat-total-completed').innerText = completedBooks.length;
            document.getElementById('stat-total-pages').innerText = totalPages;
            document.getElementById('stat-avg-daily-page').innerText = avgDaily;
            document.getElementById('stat-avg-days-book').innerText = avgDaysBook;

            renderCharts(completedBooks);
        }

        function renderCharts(completedBooks) {
            // Chart 1: Monthly Completed
            const monthlyCounts = {};
            completedBooks.forEach(b => {
                if(b.finishDate) {
                    const m = b.finishDate.slice(0, 7);
                    monthlyCounts[m] = (monthlyCounts[m] || 0) + 1;
                }
            });
            const labels1 = Object.keys(monthlyCounts).sort();
            const data1 = labels1.map(k => monthlyCounts[k]);

            const ctx1 = document.getElementById('chart-monthly-books').getContext('2d');
            if(chart1) chart1.destroy();
            chart1 = new Chart(ctx1, {
                type: 'bar',
                data: {
                    labels: labels1,
                    datasets: [{ label: '読了冊数', data: data1, backgroundColor: '#4caf50' }]
                }
            });

            // Chart 2: Daily Page Progress (Approximation)
            // Shows sum of pages READ per day (delta)
            const dailySum = {};
            books.forEach(b => {
                // To calculate delta correctly, we need to traverse logs in order
                const sortedLogs = [...b.logs].sort((a,b) => new Date(a.date) - new Date(b.date));
                sortedLogs.forEach((log, i) => {
                    const prevPage = i > 0 ? sortedLogs[i-1].page : 0;
                    const delta = log.page - prevPage;
                    if(delta > 0) {
                        dailySum[log.date] = (dailySum[log.date] || 0) + delta;
                    }
                });
            });
            
            const labels2 = Object.keys(dailySum).sort();
            const data2 = labels2.map(k => dailySum[k]);

            const ctx2 = document.getElementById('chart-daily-pages').getContext('2d');
            if(chart2) chart2.destroy();
            chart2 = new Chart(ctx2, {
                type: 'line',
                data: {
                    labels: labels2,
                    datasets: [{ label: '1日の読書ページ数', data: data2, borderColor: '#64b5f6', tension: 0.1 }]
                }
            });
        }

        // Init
        resetRecordForms();
        populateLogSelect();
    </script>
</body>
</html>

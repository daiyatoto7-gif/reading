<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>読書管理アプリ</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            /* Dark Theme Base */
            --bg-color: #121212;
            --card-bg: #1e1e1e;
            --text-color: #e0e0e0;
            --text-muted: #a0a0a0;
            --primary-color: #64b5f6;
            --border-color: #333;
            --input-bg: #2c2c2c;
            
            /* Status Colors */
            --status-unread: #757575;
            --status-reading: #4caf50;
            --status-completed: #2196f3;
            --status-dropped: #f44336;
        }

        body {
            font-family: "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            padding-bottom: 80px; /* Nav height */
            overflow-x: hidden; /* Prevent horizontal scroll */
        }

        h2, h3 { margin-top: 0; color: #fff; }

        /* Navigation Tabs */
        .nav-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: var(--card-bg);
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-around;
            padding: 10px 0;
            z-index: 1000;
        }
        .nav-item {
            text-align: center;
            cursor: pointer;
            flex: 1;
            padding: 5px;
            color: var(--text-muted);
            font-size: 11px;
        }
        .nav-item.active {
            color: var(--primary-color);
            font-weight: bold;
        }

        /* Page Layout */
        .page {
            display: none;
            padding: 15px; /* Reduced padding for mobile */
            max-width: 800px;
            margin: 0 auto;
        }
        .page.active { display: block; }

        /* Cards & Inputs */
        .card {
            background: var(--card-bg);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }
        input, select, textarea {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: white;
            box-sizing: border-box;
        }
        input[type="date"] { color-scheme: dark; }
        
        button {
            background-color: var(--primary-color);
            color: #121212;
            border: none;
            padding: 12px 20px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            font-size: 16px;
            font-weight: bold;
        }
        button:hover { opacity: 0.9; }
        button.secondary { background-color: #424242; color: white; margin-top: 5px; }
        button.danger { background-color: #cf6679; color: black; margin-top: 5px; }

        /* Utility */
        .hidden { display: none; }
        .flex { display: flex; gap: 10px; }
        .text-small { font-size: 12px; color: var(--text-muted); }
        
        /* Badges */
        .status-badge {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            color: white;
            margin-left: 5px;
            vertical-align: middle;
        }
        .status-unread { background-color: var(--status-unread); }
        .status-reading { background-color: var(--status-reading); }
        .status-completed { background-color: var(--status-completed); }
        .status-dropped { background-color: var(--status-dropped); }

        /* Lists */
        .book-item {
            border-bottom: 1px solid var(--border-color);
            padding: 12px 0;
        }

        /* --- Calendar Styles (Refined) --- */
        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        /* Grid Container */
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr); /* Equal width columns */
            gap: 1px;
            background-color: var(--border-color);
            border: 1px solid var(--border-color);
        }

        /* Day Cell */
        .calendar-cell {
            background-color: var(--card-bg);
            min-height: 80px; /* Base height */
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent spillover */
        }

        .calendar-day-header {
            background-color: #333;
            color: #ccc;
            text-align: center;
            padding: 5px 0;
            font-size: 11px;
        }
        
        .day-number {
            font-size: 10px;
            color: var(--text-muted);
            padding: 2px 4px;
            display: block;
        }

        /* Event Bar Logic */
        .calendar-event-row {
            flex: 1; /* Take remaining space */
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            width: 100%;
        }

        .event-bar {
            height: 22px;
            margin-bottom: 2px;
            color: #121212; /* Dark text on pastel */
            font-size: 10px;
            line-height: 22px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding-left: 4px;
            font-weight: bold;
            box-sizing: border-box;
            /* Default: look connected */
            border-radius: 0; 
        }

        /* Rounded corners for start/end of the bar */
        .event-start { border-top-left-radius: 4px; border-bottom-left-radius: 4px; }
        .event-end { border-top-right-radius: 4px; border-bottom-right-radius: 4px; }

        /* Memo History */
        .memo-history {
            margin-top: 10px;
            padding: 10px;
            background: #252525;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
        }
        .memo-item {
            border-bottom: 1px solid #444;
            padding: 8px 0;
            font-size: 13px;
        }
        .memo-date { color: var(--primary-color); font-weight: bold; margin-right: 5px; }

        /* Chart adjustments */
        canvas { max-width: 100%; margin-bottom: 20px; }
    </style>
</head>
<body>

    <div id="tab-record" class="page active">
        <h2>記録をつける</h2>
        <div class="card">
            <h3>メニュー</h3>
            <div class="flex">
                <button onclick="showRecordSection('add-new')">新しい本を追加</button>
                <button onclick="showRecordSection('log-reading')">読書記録をつける</button>
            </div>
            <div style="margin-top: 10px;">
                <button class="secondary" onclick="showRecordSection('change-status')">ステータスを変更</button>
            </div>
        </div>

        <div id="section-add-new" class="card hidden">
            <h3>新しい本を追加</h3>
            <label>タイトル (必須)</label>
            <input type="text" id="new-title" placeholder="本のタイトル">
            <label>読み始めた日 (空欄なら自動)</label>
            <input type="date" id="new-start-date">
            <label>今回読んだ日付 (任意)</label>
            <input type="date" id="new-log-date">
            <label>どこまで読んだか (ページ数)</label>
            <input type="number" id="new-page" placeholder="例: 50">
            <label>読み終えた日 (読了時のみ)</label>
            <input type="date" id="new-finish-date">
            <label>メモ</label>
            <textarea id="new-memo" placeholder="感想など"></textarea>
            <button onclick="addNewBook()">追加する</button>
        </div>

        <div id="section-log-reading" class="card hidden">
            <h3>読書記録をつける</h3>
            <p class="text-small">未読または読書中の本のみ表示</p>
            <select id="log-book-select" onchange="updateCurrentPageDisplay()"></select>
            <p id="current-page-display" style="font-weight:bold; color:var(--primary-color);">現在: 0ページ</p>
            <label>読んだ日付</label>
            <input type="date" id="log-date">
            <label>どこまで読んだか (ページ数)</label>
            <input type="number" id="log-page">
            <label>メモ</label>
            <textarea id="log-memo" placeholder="今日の感想"></textarea>
            <button onclick="addLog()">記録する</button>
            <div class="flex" style="margin-top:10px;">
                <button class="secondary" onclick="finishBookFromLog()">読了する</button>
                <button class="danger" onclick="dropBookFromLog()">離脱する</button>
            </div>
        </div>

        <div id="section-change-status" class="card hidden">
            <h3>ステータスを変更・編集</h3>
            <input type="text" id="status-search" placeholder="本の名前で検索..." onkeyup="renderStatusList()">
            <div id="status-book-list"></div>
        </div>
    </div>

    <div id="tab-bookshelf" class="page">
        <h2>本棚</h2>
        <div class="flex" style="margin-bottom: 15px;">
            <button class="secondary" onclick="renderBookshelf('reading')">読書中</button>
            <button class="secondary" onclick="renderBookshelf('all')">すべて</button>
            <button class="secondary" onclick="renderBookshelf('unread')">未読</button>
            <button class="secondary" onclick="renderBookshelf('dropped')">離脱</button>
        </div>
        <div id="bookshelf-list" class="card"></div>
    </div>

    <div id="edit-screen" class="page">
        <button class="secondary" onclick="closeEditScreen()" style="width:auto; margin-bottom:10px;">← 戻る</button>
        <h2>詳細編集</h2>
        <div class="card">
            <input type="hidden" id="edit-id">
            <label>タイトル</label>
            <input type="text" id="edit-title">
            <label>ステータス</label>
            <select id="edit-status">
                <option value="unread">未読</option>
                <option value="reading">読書中</option>
                <option value="completed">読了</option>
                <option value="dropped">離脱中</option>
            </select>
            <label>読み始めた日</label>
            <input type="date" id="edit-start-date">
            <label>現在の到達ページ（記録を追加）</label>
            <input type="number" id="edit-current-page">
            <label>読み終えた日</label>
            <input type="date" id="edit-finish-date">
            <h3>読書履歴・メモ</h3>
            <div id="edit-memo-history" class="memo-history"></div>
            <button onclick="saveEdit()" style="margin-top:20px;">変更を保存</button>
            <button class="danger" onclick="deleteBook()" style="margin-top:10px;">この本を削除</button>
        </div>
    </div>

    <div id="tab-calendar" class="page">
        <h2>カレンダー</h2>
        <div class="card">
            <div class="calendar-header">
                <button class="secondary" style="width:auto; padding: 5px 15px;" onclick="changeMonth(-1)">&lt;</button>
                <h3 id="calendar-title" style="margin:0;"></h3>
                <button class="secondary" style="width:auto; padding: 5px 15px;" onclick="changeMonth(1)">&gt;</button>
            </div>
            <div class="calendar-grid" id="calendar-grid">
                </div>
        </div>
    </div>

    <div id="tab-stats" class="page">
        <h2>統計情報</h2>
        <div class="card">
            <p><strong>累計読了冊数:</strong> <span id="stat-total-completed">0</span> 冊</p>
            <p><strong>累計読書ページ数:</strong> <span id="stat-total-pages">0</span> ページ</p>
            <p><strong>1日平均ページ数:</strong> <span id="stat-avg-daily-page">0</span> ページ</p>
            <p><strong>1冊平均読了日数:</strong> <span id="stat-avg-days-book">0</span> 日</p>
        </div>
        
        <div class="card">
            <h3>日別 読書ページ数（直近1週間）</h3>
            <canvas id="chart-daily-pages"></canvas>
        </div>
        <div class="card">
            <h3>週別 読書ページ推移</h3>
            <canvas id="chart-weekly-pages"></canvas>
        </div>
        <div class="card">
            <h3>月別 読書ページ推移</h3>
            <canvas id="chart-monthly-pages"></canvas>
        </div>
    </div>

    <div class="nav-bar">
        <div class="nav-item active" onclick="switchTab('record')">記録</div>
        <div class="nav-item" onclick="switchTab('bookshelf')">本棚</div>
        <div class="nav-item" onclick="switchTab('calendar')">カレンダー</div>
        <div class="nav-item" onclick="switchTab('stats')">統計</div>
    </div>

    <script>
        // --- Data & Colors ---
        let books = JSON.parse(localStorage.getItem('readingApp_books')) || [];
        let currentCalendarDate = new Date();

        // Palette for distinct book colors (Pastel tones for legibility)
        const colorPalette = [
            '#FFAB91', '#80CBC4', '#90CAF9', '#CE93D8', '#E6EE9C', 
            '#F48FB1', '#B39DDB', '#81D4FA', '#A5D6A7', '#FFE082'
        ];

        function getBookColor(id) {
            // Simple hash based selection
            const index = id % colorPalette.length;
            return colorPalette[index];
        }

        function saveData() {
            localStorage.setItem('readingApp_books', JSON.stringify(books));
        }

        // Chart defaults
        Chart.defaults.color = '#a0a0a0';
        Chart.defaults.borderColor = '#333';

        // --- Tab Switching ---
        function switchTab(tabName) {
            document.querySelectorAll('.page').forEach(el => el.classList.remove('active'));
            document.getElementById(`tab-${tabName}`).classList.add('active');
            document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
            const navIndex = ['record', 'bookshelf', 'calendar', 'stats'].indexOf(tabName);
            if(navIndex >= 0) document.querySelectorAll('.nav-item')[navIndex].classList.add('active');

            if(tabName === 'record') resetRecordForms();
            if(tabName === 'bookshelf') renderBookshelf('all');
            if(tabName === 'calendar') renderCalendar();
            if(tabName === 'stats') renderStats();
        }

        // --- Record / Bookshelf Logic (Same as before) ---
        function showRecordSection(section) {
            document.getElementById('section-add-new').classList.add('hidden');
            document.getElementById('section-log-reading').classList.add('hidden');
            document.getElementById('section-change-status').classList.add('hidden');
            document.getElementById(`section-${section}`).classList.remove('hidden');
            if(section === 'log-reading') populateLogSelect();
            if(section === 'change-status') renderStatusList();
        }

        function resetRecordForms() {
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('new-log-date').value = today;
            document.getElementById('log-date').value = today;
        }

        function addNewBook() {
            const title = document.getElementById('new-title').value;
            if(!title) return alert("タイトルは必須です");
            const startDate = document.getElementById('new-start-date').value;
            const logDate = document.getElementById('new-log-date').value;
            const page = parseInt(document.getElementById('new-page').value) || 0;
            const finishDate = document.getElementById('new-finish-date').value;
            const memo = document.getElementById('new-memo').value;

            const newBook = {
                id: Date.now(),
                title: title,
                status: 'unread',
                startDate: startDate || '',
                finishDate: finishDate || '',
                logs: []
            };

            if(logDate || page > 0) {
                if(!newBook.startDate && logDate) newBook.startDate = logDate;
                newBook.status = 'reading';
                if(finishDate) newBook.status = 'completed';
                newBook.logs.push({ date: logDate || new Date().toISOString().split('T')[0], page: page, memo: memo });
            }

            books.push(newBook);
            saveData();
            alert("本を追加しました");
            document.getElementById('new-title').value = '';
            document.getElementById('new-page').value = '';
            document.getElementById('new-memo').value = '';
            showRecordSection('log-reading');
        }

        function populateLogSelect() {
            const select = document.getElementById('log-book-select');
            select.innerHTML = '<option value="">本を選択してください</option>';
            const activeBooks = books.filter(b => b.status === 'unread' || b.status === 'reading');
            activeBooks.forEach(b => {
                const opt = document.createElement('option');
                opt.value = b.id;
                opt.textContent = b.title;
                select.appendChild(opt);
            });
        }

        function updateCurrentPageDisplay() {
            const bookId = document.getElementById('log-book-select').value;
            const display = document.getElementById('current-page-display');
            if(!bookId) { display.innerText = "現在: - ページ"; return; }
            const book = books.find(b => b.id == bookId);
            const maxPage = book.logs.length > 0 ? book.logs[book.logs.length - 1].page : 0;
            display.innerText = `現在: ${maxPage} ページ`;
        }

        function addLog() {
            const bookId = document.getElementById('log-book-select').value;
            if(!bookId) return alert("本を選択してください");
            const date = document.getElementById('log-date').value;
            const page = parseInt(document.getElementById('log-page').value);
            const memo = document.getElementById('log-memo').value;

            if(!date || isNaN(page)) return alert("日付とページ数は必須です");
            const book = books.find(b => b.id == bookId);
            const currentPage = book.logs.length > 0 ? book.logs[book.logs.length - 1].page : 0;
            
            if(page < currentPage) {
                alert(`エラー: ページ数が減っています。`);
                return;
            }

            if(book.status === 'unread') {
                book.status = 'reading';
                if(!book.startDate) book.startDate = date;
            }
            book.logs.push({ date, page, memo });
            book.logs.sort((a,b) => new Date(a.date) - new Date(b.date));
            saveData();
            alert("記録しました");
            document.getElementById('log-memo').value = ''; 
            document.getElementById('log-page').value = '';
            updateCurrentPageDisplay();
        }

        function finishBookFromLog() {
            const bookId = document.getElementById('log-book-select').value;
            if(!bookId) return alert("本を選択してください");
            const date = document.getElementById('log-date').value;
            const book = books.find(b => b.id == bookId);
            book.status = 'completed';
            book.finishDate = date || new Date().toISOString().split('T')[0];
            saveData();
            alert("「読了」に変更しました");
            populateLogSelect();
        }

        function dropBookFromLog() {
            const bookId = document.getElementById('log-book-select').value;
            if(!bookId) return alert("本を選択してください");
            const book = books.find(b => b.id == bookId);
            book.status = 'dropped';
            saveData();
            alert("「離脱」に変更しました");
            populateLogSelect();
        }

        function renderStatusList() {
            const container = document.getElementById('status-book-list');
            const search = document.getElementById('status-search').value.toLowerCase();
            container.innerHTML = '';
            const filtered = books.filter(b => b.title.toLowerCase().includes(search));
            filtered.forEach(b => {
                const div = document.createElement('div');
                div.className = 'book-item flex';
                div.style.justifyContent = 'space-between';
                div.innerHTML = `<span>${b.title} <span class="status-badge status-${b.status}">${getStatusLabel(b.status)}</span></span><button class="secondary" style="width:auto; padding:5px 10px;" onclick="openEditScreen(${b.id})">編集</button>`;
                container.appendChild(div);
            });
        }

        function renderBookshelf(filterStatus) {
            const list = document.getElementById('bookshelf-list');
            list.innerHTML = '';
            let filtered = books;
            if(filterStatus !== 'all') filtered = books.filter(b => b.status === filterStatus);
            if(filtered.length === 0) { list.innerHTML = '<p style="text-align:center; color:#777;">本がありません</p>'; return; }
            filtered.forEach(b => {
                const div = document.createElement('div');
                div.className = 'book-item';
                div.innerHTML = `<div class="flex" style="justify-content:space-between; align-items:center;"><div><strong>${b.title}</strong><span class="status-badge status-${b.status}">${getStatusLabel(b.status)}</span><div class="text-small" style="margin-top:4px;">開始: ${b.startDate || '-'} / 完了: ${b.finishDate || '-'}</div></div><button class="secondary" style="width:auto;" onclick="openEditScreen(${b.id})">編集</button></div>`;
                list.appendChild(div);
            });
        }
        
        function getStatusLabel(status) {
            const map = { unread:'未読', reading:'読書中', completed:'読了', dropped:'離脱' };
            return map[status] || status;
        }

        function openEditScreen(id) {
            const book = books.find(b => b.id == id);
            if(!book) return;
            document.getElementById('edit-id').value = book.id;
            document.getElementById('edit-title').value = book.title;
            document.getElementById('edit-status').value = book.status;
            document.getElementById('edit-start-date').value = book.startDate;
            document.getElementById('edit-finish-date').value = book.finishDate;
            const currentP = book.logs.length > 0 ? book.logs[book.logs.length - 1].page : 0;
            document.getElementById('edit-current-page').value = currentP;
            const historyDiv = document.getElementById('edit-memo-history');
            historyDiv.innerHTML = '';
            const sortedLogs = [...book.logs].sort((a,b) => new Date(b.date) - new Date(a.date));
            sortedLogs.forEach(log => {
                const d = document.createElement('div');
                d.className = 'memo-item';
                d.innerHTML = `<span class="memo-date">${log.date}</span> ${log.page}ページまで <br> ${log.memo || '(メモなし)'}`;
                historyDiv.appendChild(d);
            });
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            document.getElementById('edit-screen').classList.add('active');
        }

        function closeEditScreen() {
            document.getElementById('edit-screen').classList.remove('active');
            switchTab('bookshelf');
        }

        function saveEdit() {
            const id = document.getElementById('edit-id').value;
            const book = books.find(b => b.id == id);
            book.title = document.getElementById('edit-title').value;
            book.status = document.getElementById('edit-status').value;
            book.startDate = document.getElementById('edit-start-date').value;
            book.finishDate = document.getElementById('edit-finish-date').value;
            const inputPage = parseInt(document.getElementById('edit-current-page').value);
            const lastLog = book.logs.length > 0 ? book.logs[book.logs.length - 1] : null;
            if (!lastLog || lastLog.page !== inputPage) {
                 book.logs.push({ date: new Date().toISOString().split('T')[0], page: inputPage, memo: '編集画面で更新' });
                 book.logs.sort((a,b) => new Date(a.date) - new Date(b.date));
            }
            saveData();
            alert("変更を保存しました");
            closeEditScreen();
        }

        function deleteBook() {
            if(!confirm("本当に削除しますか？")) return;
            const id = document.getElementById('edit-id').value;
            books = books.filter(b => b.id != id);
            saveData();
            closeEditScreen();
        }

        // --- Improved Calendar Logic (Grid with Continuous Bars) ---
        function changeMonth(offset) {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() + offset);
            renderCalendar();
        }

        function renderCalendar() {
            const year = currentCalendarDate.getFullYear();
            const month = currentCalendarDate.getMonth();
            document.getElementById('calendar-title').innerText = `${year}年 ${month + 1}月`;
            
            const grid = document.getElementById('calendar-grid');
            grid.innerHTML = '';

            const days = ['日', '月', '火', '水', '木', '金', '土'];
            days.forEach(d => {
                const h = document.createElement('div');
                h.className = 'calendar-day-header';
                h.innerText = d;
                grid.appendChild(h);
            });

            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const startDayIndex = firstDay.getDay(); 
            const totalDays = lastDay.getDate();

            // Padding days
            for(let i=0; i<startDayIndex; i++) {
                const empty = document.createElement('div');
                empty.className = 'calendar-cell';
                empty.style.background = 'transparent';
                grid.appendChild(empty);
            }

            const todayStr = new Date().toISOString().split('T')[0];

            for(let d=1; d<=totalDays; d++) {
                const cellDate = new Date(year, month, d);
                const cellDateStr = cellDate.toISOString().split('T')[0];
                const dayIndex = cellDate.getDay(); // 0(Sun) - 6(Sat)

                const cell = document.createElement('div');
                cell.className = 'calendar-cell';
                if(cellDateStr === todayStr) cell.style.border = '1px solid var(--primary-color)';
                
                cell.innerHTML = `<span class="day-number">${d}</span><div class="calendar-event-row"></div>`;
                const rowContainer = cell.querySelector('.calendar-event-row');

                // Find events for this day
                // To handle diagonal split, we look for:
                // Book A Ends Today AND Book B Starts Today
                
                let endingBook = null;
                let startingBook = null;
                let continuingBook = null;

                // Simple priority: Diagonal > Single Active
                
                // Identify roles
                books.forEach(b => {
                    if(b.status === 'dropped' || !b.startDate) return;
                    
                    const start = new Date(b.startDate); start.setHours(0,0,0,0);
                    let end = b.finishDate ? new Date(b.finishDate) : new Date(); end.setHours(0,0,0,0);
                    
                    if(cellDate.getTime() === end.getTime()) endingBook = b;
                    if(cellDate.getTime() === start.getTime()) startingBook = b;
                    
                    if(cellDate >= start && cellDate <= end) {
                        continuingBook = b;
                    }
                });

                // Rendering Logic
                let bar = document.createElement('div');
                bar.className = 'event-bar';
                
                // Diagonal Split Case
                if (endingBook && startingBook && endingBook.id !== startingBook.id) {
                    const colorA = getBookColor(endingBook.id);
                    const colorB = getBookColor(startingBook.id);
                    
                    bar.style.background = `linear-gradient(to bottom right, ${colorA} 45%, ${colorB} 55%)`;
                    // Diagonal usually no text, or hard to place.
                    rowContainer.appendChild(bar);
                } 
                // Normal Active Case
                else if (continuingBook) {
                    const color = getBookColor(continuingBook.id);
                    bar.style.backgroundColor = color;
                    
                    // Logic for visual continuity
                    const start = new Date(continuingBook.startDate); start.setHours(0,0,0,0);
                    let end = continuingBook.finishDate ? new Date(continuingBook.finishDate) : new Date(); end.setHours(0,0,0,0);

                    // Rounded corners
                    if(cellDate.getTime() === start.getTime()) bar.classList.add('event-start');
                    if(cellDate.getTime() === end.getTime()) bar.classList.add('event-end');

                    // Show Title Logic: Start of Book OR Start of Week (Sunday)
                    if(cellDate.getTime() === start.getTime() || dayIndex === 0) {
                         bar.innerText = continuingBook.title;
                    } else {
                        // Empty text for continuity
                        bar.innerHTML = '&nbsp;';
                    }
                    
                    rowContainer.appendChild(bar);
                }

                grid.appendChild(cell);
            }
        }

        // --- Statistics Logic (Charts Updated) ---
        let chartDaily = null;
        let chartWeekly = null;
        let chartMonthly = null;

        function renderStats() {
            // Aggregate Logs
            let dailyMap = {};
            books.forEach(b => {
                // Calculate daily delta
                const sortedLogs = [...b.logs].sort((a,b) => new Date(a.date) - new Date(b.date));
                sortedLogs.forEach((log, i) => {
                    const prevPage = i > 0 ? sortedLogs[i-1].page : 0;
                    const delta = log.page - prevPage;
                    if(delta > 0) {
                        dailyMap[log.date] = (dailyMap[log.date] || 0) + delta;
                    }
                });
            });

            // Averages Logic (same as before)
            // ... (Simple stats text update)
            const completedBooks = books.filter(b => b.status === 'completed');
            let totalPages = 0;
            books.forEach(b => { if(b.logs.length) totalPages += Math.max(...b.logs.map(l=>l.page)); });
            
            let allLogsDates = [];
            books.forEach(b => b.logs.forEach(l => allLogsDates.push(new Date(l.date))));
            let avgDaily = 0;
            if(allLogsDates.length > 0) {
                const minDate = new Date(Math.min.apply(null, allLogsDates));
                const diffDays = Math.max(1, Math.ceil((new Date() - minDate) / (86400000))); 
                avgDaily = Math.round(totalPages / diffDays);
            }
            let totalDaysForBooks = 0;
            completedBooks.forEach(b => {
                const s = new Date(b.startDate); const e = new Date(b.finishDate);
                totalDaysForBooks += Math.max(1, Math.ceil((e - s) / 86400000) + 1);
            });
            const avgDaysBook = completedBooks.length ? Math.round(totalDaysForBooks / completedBooks.length) : 0;

            document.getElementById('stat-total-completed').innerText = completedBooks.length;
            document.getElementById('stat-total-pages').innerText = totalPages;
            document.getElementById('stat-avg-daily-page').innerText = avgDaily;
            document.getElementById('stat-avg-days-book').innerText = avgDaysBook;

            // --- Render 3 Charts ---
            renderChartDaily(dailyMap);
            renderChartWeekly(dailyMap);
            renderChartMonthly(dailyMap);
        }

        // 1. Last 7 Days
        function renderChartDaily(dailyMap) {
            const today = new Date();
            const labels = [];
            const data = [];
            
            for(let i=6; i>=0; i--) {
                const d = new Date(today);
                d.setDate(d.getDate() - i);
                const dStr = d.toISOString().split('T')[0];
                labels.push(dStr.slice(5)); // MM-DD
                data.push(dailyMap[dStr] || 0);
            }

            const ctx = document.getElementById('chart-daily-pages').getContext('2d');
            if(chartDaily) chartDaily.destroy();
            chartDaily = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{ label: 'ページ数', data: data, backgroundColor: '#64b5f6' }]
                }
            });
        }

        // 2. Weekly Progress
        function renderChartWeekly(dailyMap) {
            // Aggregate by ISO Week or simple start of week
            const weeklyData = {};
            Object.keys(dailyMap).forEach(dateStr => {
                const d = new Date(dateStr);
                // Get Monday of that week
                const day = d.getDay() || 7; 
                if(day !== 1) d.setHours(-24 * (day - 1)); 
                const weekLabel = d.toISOString().split('T')[0];
                weeklyData[weekLabel] = (weeklyData[weekLabel] || 0) + dailyMap[dateStr];
            });

            const sortedWeeks = Object.keys(weeklyData).sort().slice(-8); // Last 8 weeks
            const labels = sortedWeeks.map(w => w.slice(5) + '~');
            const data = sortedWeeks.map(w => weeklyData[w]);

            const ctx = document.getElementById('chart-weekly-pages').getContext('2d');
            if(chartWeekly) chartWeekly.destroy();
            chartWeekly = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{ label: '週間ページ数', data: data, borderColor: '#81c784', tension: 0.1 }]
                }
            });
        }

        // 3. Monthly Progress
        function renderChartMonthly(dailyMap) {
            const monthlyData = {};
            Object.keys(dailyMap).forEach(dateStr => {
                const month = dateStr.slice(0, 7); // YYYY-MM
                monthlyData[month] = (monthlyData[month] || 0) + dailyMap[dateStr];
            });

            const sortedMonths = Object.keys(monthlyData).sort().slice(-6); // Last 6 months
            const labels = sortedMonths;
            const data = sortedMonths.map(m => monthlyData[m]);

            const ctx = document.getElementById('chart-monthly-pages').getContext('2d');
            if(chartMonthly) chartMonthly.destroy();
            chartMonthly = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{ label: '月間ページ数', data: data, backgroundColor: '#ba68c8' }]
                }
            });
        }

        // Init
        resetRecordForms();
        populateLogSelect();
    </script>
</body>
</html>
